import InputMask from 'inputmask-core'
import keyboard from '../../utils/keyboard'

const inputMasks = new WeakMap()

const getSelection = (input) => {
    return {
        start: input.selectionStart,
        end: input.selectionEnd,
    }
}

const setSelection = (input, selection) => {
    input.focus()
    input.setSelectionRange(selection.start, selection.end)
}

const removePlaceholderCharacters = (value, placeholderCharacters) => value.split('')
    .reduce((accumulated, currentCharacter, currentIndex) =>
        (
            accumulated.length === currentIndex && !placeholderCharacters.includes(currentCharacter) ?
                `${accumulated}${currentCharacter}` : accumulated
        ), ''
    )

class MaskedInput {
    constructor(options) {
        const inputMask = new InputMask({
            ...options,
        })

        inputMasks.set(this, inputMask)
    }

    updateMaskSelection(input) {
        const inputMask = inputMasks.get(this)
        inputMask.selection = getSelection(input)
        return Promise.resolve(inputMask.selection)
    }

    updateInputSelection(input) {
        const inputMask = inputMasks.get(this)
        setSelection(input, inputMask.selection)
        return new Promise((resolve) => {
            setTimeout(() => {
                setSelection(input, inputMask.selection)
                resolve(inputMask.selection)
            }, 0)
        })
    }

    getInputSelection(input) {
        const inputMask = inputMasks.get(this)
        const selection = getSelection(input)
        let value = input.value.slice(0, selection.end)
        for (let i = selection.end, l = selection.start; i >= l; i--) {
            if (!inputMask.pattern.isEditableIndex(i) || value.charAt(i) === inputMask.placeholderChar) {
                value = `${value.slice(0,i)}${value.slice(i + 1)}`
            }
        }
        return value.slice(selection.start)
    }

    get mask() {
        return inputMasks.get(this)
    }

    get firstEmptyIndex() {
        const value = this.displayValue
        let i = this.mask.pattern.firstEditableIndex
        while (i <= value.length && (
            !this.mask.pattern.isEditableIndex(i) || value.charAt(i) !== this.mask.placeholderChar
        )) {
            i++
        }
        return i
    }

    get selection() {
        return this.mask.selection
    }

    set selection(selection) {
        this.mask.selection = selection
    }

    get displayValue() {
        return this.mask.getValue()
    }

    get revealedValue() {
        return this.displayValue.slice(0,this.firstEmptyIndex)
    }

    set value(value) {
        const inputMask = this.mask
        inputMask.setValue(value === inputMask.emptyValue ? '' : value)
        const newValue = this.revealedValue
        inputMask.setValue(newValue)
        this.selection = {
            start: newValue.length,
            end: newValue.length,
        }
    }

    get value() {
        const inputMask = this.mask
        return removePlaceholderCharacters(inputMask.getRawValue(), [inputMask.placeholderChar])
    }

    get placeholder() {
        return this.mask.emptyValue
    }

    handleCut(event) {
        const inputMask = this && this.mask
        if (event && inputMask) {
            this.updateMaskSelection(event.target)
            if (event.clipboardData) {
                const cutData = this.getInputSelection(event.target)
                if (inputMask.backspace()) {
                    event.preventDefault()
                    cutData !== '' && event.clipboardData.setData('Text', cutData)
                    this.updateInputSelection(event.target)
                }
            }
        }
    }

    handlePaste(event) {
        const inputMask = this && this.mask
        if (event && inputMask) {
            this.updateMaskSelection(event.target)
            if (event.clipboardData) {
                let pasteData = event.clipboardData.types && event.clipboardData.types['text/plain'] ?
                    event.clipboardData.getData('text/plain') :
                    event.clipboardData.getData('Text')
                if (inputMask.selection.start < inputMask.pattern.firstEditableIndex) {
                    for (let i = inputMask.pattern.firstEditableIndex - 1, l = inputMask.selection.start; i >= l; i--) {
                        if (pasteData.charAt(i) !== inputMask.pattern.pattern[i]) {
                            pasteData = `${inputMask.pattern.pattern[i]}${pasteData}`
                        }
                    }
                }
                if (inputMask.paste(pasteData)) {
                    event.preventDefault()
                    this.updateInputSelection(event.target)
                }
            }
        }
    }

    handleKeyDown(event) {
        const inputMask = this && this.mask

        if (event && inputMask) {
            if (event.key === 'Backspace') {
                event.preventDefault()
                this.updateMaskSelection(event.target)
                if (this.selection.end === this.selection.start) {
                    let i = inputMask.selection.start - 1
                    for (; i >= inputMask.pattern.firstEditableIndex; i--) {
                        if (inputMask.pattern.isEditableIndex(i)) {
                            break
                        }
                    }
                    this.selection = {
                        start: i,
                        end: this.selection.end,
                    }
                }
                inputMask.backspace()
                this.updateInputSelection(event.target)
            }
            if (
                (keyboard.isUndo(event) && inputMask.undo()) ||
                (keyboard.isRedo(event) && inputMask.redo())
            ) {
                event.preventDefault()
                this.updateInputSelection(event.target)
            }
        }
    }

    handleKeyPress(event) {
        if (!event || event.metaKey || event.altKey || event.ctrlKey || event.key === 'Enter') {
            return
        }

        if (this && this.mask) {
            const inputMask = this.mask
            this.updateMaskSelection(event.target)

            if (inputMask.input((event.key || event.data))) {
                event.preventDefault()
                this.updateInputSelection(event.target)
                return
            }
        }
    }

    handleInput(event) {
        if (event && this && this.mask) {
            const maskValue = this.displayValue
            const incomingValue = event.target.value
            if (incomingValue !== maskValue) {
                this.updateMaskSelection(event.target)
                this.value = incomingValue
                event.target.value = this.displayValue
                this.updateInputSelection(event.target)
            }
        }
    }
}

export default MaskedInput