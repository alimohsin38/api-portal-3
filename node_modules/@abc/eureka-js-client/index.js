const os = require('os')
const corequest = require('co-request')
const Eureka = require('eureka-js-client')
const merge = require('deepmerge')
const http = require('http')

class EurekaClient extends Eureka.Eureka {
    constructor(options = {}) {
        const appId = options.app || process.env.APP_ID
        if (!appId) {
            throw Error('AppId is required. Please provide the `app` property in `options` object or set the APP_ID environment variable')
        }

        const port = options.port || process.env.PORT
        const hostname = options.hostname || process.env.HOSTNAME || os.hostname()
        const ip = options.ipAddr || process.env.IP_ADDR
        const eurekaServiceUrls = (options.eurekaServiceUrls || process.env.EUREKA_SERVICE_URLS).split(',')

        const DEFAULT_OPTIONS = {
            instance: {
                app: appId,
                hostName: hostname,
                ipAddr: ip,
                port: {
                    $: port,
                    '@enabled': 'true',
                },
                vipAddress: appId,
                dataCenterInfo: {
                    '@class': 'com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo',
                    name: 'MyOwn'
                },
                statusPageUrl: `http://${hostname}:${port}/info`,
                healthCheckUrl: `http://${hostname}:${port}/health`
            },
            eureka: {
                serviceUrls: {
                    default: eurekaServiceUrls
                },
                maxRetries: 30,
                requestRetryDelay: 500,
            }
        }

        const finalOptions = merge({}, DEFAULT_OPTIONS)
        if (options.logger) {
            finalOptions.logger = options.logger.child({module: `${options.logger.fields.module}.eureka`})
        } else {
            finalOptions.logger = require('@abc/logger').createLogger({name:`${appId}-eureka`})
        }

        if (options.eureka && options.eureka.serviceUrls && options.eureka.serviceUrls.default) {
            finalOptions.eureka.serviceUrls.default = options.eureka.serviceUrls.default
        }

        super(finalOptions)

        this.nextInstance = 0

        this.callEurekaService = this.callEurekaService.bind(this)
        this.buildUrlPathFromObject = this.buildUrlPathFromObject.bind(this)
        this.buildQueryString = this.buildQueryString.bind(this)
    }

    __getNextInstance(appId) {
        const instances = this.getInstancesByAppId(appId)
        if (!instances || !instances.length) {
            throw Error(`Unable to get eureka instances for app id ${appId}`)
        }

        let serviceInstance = instances[this.nextInstance]
        // eslint-disable-next-line no-extra-boolean-cast
        if (!!serviceInstance) {
            this.nextInstance = (this.nextInstance + 1) % instances.length
        } else {
            serviceInstance = instances[0]
            this.nextInstance = 0
        }

        return serviceInstance
    }

    callEurekaService(serviceName, requestOptions, errMsg) {
        if (!serviceName) {
            throw Error('Service Name is required')
        }

        const instance = this.__getNextInstance(serviceName)
        requestOptions.url = `${instance.homePageUrl}${requestOptions.url}`

        return corequest(requestOptions)
            .then((response) => {
                let body = {status: http.STATUS_CODES[response.statusCode], statusCode: response.statusCode}

                try {
                    body = JSON.parse(response.body)
                } catch (e) {
                    if (typeof response.body === 'string') {
                        body = response.body ? {id: response.body} : {status: http.STATUS_CODES[response.statusCode]}
                    } else {
                        body = response.body
                    }
                }

                if (response.statusCode > 399) {
                    throw Object.assign(new Error(`${errMsg} -- Service response ${JSON.stringify(response.body)}`), {status: response.statusCode, body})
                }
                return body
            })
            .catch((err) => {
                throw err
            })
    }

    /**
     * @deprecated Since version 2.1.0. Will be deleted in the future. Use buildQueryString instead.
     */
    buildUrlPathFromObject(object) {
        console.warn('buildUrlPathFromObject method is deprecated in v2.1.0. Please use buildQueryString method in its place.')
        return this.buildQueryString(object)
    }

    buildQueryString(object) {
        const keys = Object.keys(object)
        const parameterArray = keys.reduce((accumulatorArray, key) => {
            if (object.hasOwnProperty(key)) {
                if (Array.isArray(object[key])) {
                    object[key].forEach(v => accumulatorArray.push(`${key}=${encodeURIComponent(v)}`))
                } else {
                    const value = (object[key]) ? encodeURIComponent(object[key]) : ''
                    value && accumulatorArray.push(`${key}=${value}`)
                }
            }
            return accumulatorArray
        }, [])
        return parameterArray.join('&')
    }
}

module.exports = EurekaClient
