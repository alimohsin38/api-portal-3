require('isomorphic-fetch')
const deepmerge = require('deepmerge')


class Fetcher {

    constructor() {
        this.defaultOpts = {
            cache: 'no-cache',
            headers: {
                'Content-Type': 'application/json'
            }
        }

        this.jsonOpts = {
            headers: {
                Accept: 'application/json'
            }
        }

        this.textOpts = {
            headers: {
                Accept: 'text/*'
            }
        }
        this.locationHeaderKey = 'ABCFS-LOCATION-ID'
        this.organizationHeaderKey = 'ABCFS-ORGANIZATION-ID'
    }

    setCsrf(token) {
        this.defaultOpts.headers['X-CSRF-TOKEN'] = token
    }

    setAuth(token) {
        this.defaultOpts.headers.Authorization = token
    }

    setLocation(locationId) {
        this.defaultOpts.headers[this.locationHeaderKey] = locationId
    }

    setOrganization(organizationId) {
        this.defaultOpts.headers[this.organizationHeaderKey] = organizationId
    }

    clearAuth() {
        delete this.defaultOpts.headers.Authorization
    }

    clearLocation() {
        delete this.defaultOpts.headers[this.locationHeaderKey]
    }

    clearOrganization() {
        delete this.defaultOpts.headers[this.organizationHeaderKey]
    }

    setErrorCallback(callback) {
        this.errorCallback = callback
    }

    get(url, opts = {}) {
        return this._buildFetch(url, null, opts, 'GET')
    }

    head(url, data, opts = {}) {
        return this._buildFetch(url, data, opts, 'HEAD')
    }

    post(url, data, opts = {}) {
        return this._buildFetch(url, data, opts, 'POST')
    }

    put(url, data, opts = {}) {
        return this._buildFetch(url, data, opts, 'PUT')
    }

    del(url, data, opts = {}) {
        return this._buildFetch(url, data, opts, 'DELETE')
    }

    // ---- Private Methods

    _buildFetch(url, data, opts, method) {
        const _buildOpts = deepmerge(this.defaultOpts, opts)
        _buildOpts.method = method

        if (data !== null) {
            _buildOpts.body = (typeof data === 'object') ? JSON.stringify(data) : data
        }

        return {
            then: fn => this._fetch(url, _buildOpts)
                .then(res => fn(res))
                .catch(err => this._catchThrowErrors(err)),
            json: fn => this._fetchJson(url, _buildOpts)
                .then(res => fn(res))
                .catch(err => this._catchThrowErrors(err)),
            text: fn => this._fetchText(url, _buildOpts)
                .then(res => fn(res))
                .catch(err => this._catchThrowErrors(err)),
            noResponse: () => this._fetch(url, _buildOpts)
        }
    }

    _catchThrowErrors(err) {
        if (this.errorCallback) {
            this.errorCallback(err)
        } else {
            throw err
        }
    }

    _checkResponse(res) {
        if (res.status >= 200 && res.status < 300) {
            return res
        }

        const _err = new Error(res.statusText)
        _err.response = res
        throw _err
        // we are throwing an error, so no need to return a response
    }

    _fetch(url, opts) {
        return fetch(url, opts).then(res => this._checkResponse(res))
    }

    _fetchJson(url, opts) {
        const _opts = deepmerge(this.jsonOpts, opts)

        return this._fetch(url, _opts).then(res => res.json())
    }

    _fetchText(url, opts) {
        const _opts = deepmerge(this.textOpts, opts)

        return this._fetch(url, _opts).then(res => res.text())
    }
}

module.exports = new Fetcher()