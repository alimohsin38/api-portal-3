import React, {Component} from 'react'
import PropTypes from 'prop-types'
import moment from 'moment'
import padStart from 'lodash.padstart'
import classnames from 'classnames'
import {Indicator, SecondaryFont} from '@abc/protonpack'
import styles from './timer.styl'

const timerIntervals = new WeakMap()

export default class Timer extends Component {
    constructor(props) {
        super(props)

        const start = moment(props.currentTime)
        const end = moment(props.endTime)
        const duration = moment.duration(end.diff(start, 'seconds'), 'seconds')

        this.state = {
            timeLeft: duration,
            status: null,
            hide: props.lastHourOnly && Math.abs(duration.asSeconds()) > 3599,
        }

        timerIntervals.set(this, this.runTimer())

        this.runTimer = this.runTimer.bind(this)
    }

    buildClasses() {
        const {lastHourOnly, className} = this.props

        return classnames(
            className,
            styles.container,
            {[styles.vanish]: (lastHourOnly && this.state.hide)},
        )
    }

    componentDidMount() {
        const timeLeft = this.state.timeLeft.asSeconds()
        const {danger, warning, onHide} = this.props

        if (danger && timeLeft <= danger.time) {
            this.handleDanger(timeLeft, danger.callback)
        } else if (warning && timeLeft <= warning.time) {
            this.handleWarning(timeLeft, warning.callback)
        }

        if (onHide && this.state.hide) {
            onHide()
        }
    }

    componentWillUnmount() {
        clearInterval(timerIntervals.get(this))
    }

    handleDanger(timeLeft, callback) {
        if (!this.state.dangerCalled) {
            this.setState({status: 'danger', dangerCalled: true})
            callback(Math.ceil(timeLeft))
        }
    }

    handleWarning(timeLeft, callback) {
        if (!this.state.warningCalled) {
            this.setState({status: 'warning', warningCalled: true})
            callback(Math.ceil(timeLeft))
        }
    }

    handleTick() {
        const currentSeconds = this.state.timeLeft.asSeconds()
        const {onTick, onHide, lastHourOnly, warning, danger} = this.props

        if (lastHourOnly && Math.abs(currentSeconds) > 3599 && !this.state.hide) {
            if (onHide) {
                onHide()
            }

            this.setState({hide: true})
        }

        if (danger && currentSeconds <= danger.time) {
            this.handleDanger(currentSeconds, danger.callback)
        } else if (warning && currentSeconds <= warning.time) {
            this.handleWarning(currentSeconds, warning.callback)
        }

        if (onTick) {
            onTick(currentSeconds)
        }
    }

    runTimer() {
        return setInterval(() => {
            this.setState({
                timeLeft: this.state.timeLeft.subtract(1, 'seconds'),
            }, this.handleTick)
        }, 1000)
    }

    formatTime(timeLeft, oneHour) {
        const millisecondsLeft = timeLeft.asMilliseconds()
        const absoluteTimeLeft = moment.duration(Math.abs(millisecondsLeft))

        const days = absoluteTimeLeft.days()
        const hours = absoluteTimeLeft.hours()
        const minutes = absoluteTimeLeft.minutes()
        const seconds = absoluteTimeLeft.seconds()

        // set to hour max if oneHour flag is used
        let formattedTimeLeft = (hours > 0 && oneHour) ? '59:59' : `${this.pad(minutes)}:${this.pad(seconds)}`

        if (!oneHour) {
            if (hours > 0) {
                formattedTimeLeft = `${this.pad(hours)}:${formattedTimeLeft}`
            }

            if (days > 0) {
                formattedTimeLeft = `${days}:${formattedTimeLeft}`
            }
        }

        return (millisecondsLeft < 0) ? `-${formattedTimeLeft}` : formattedTimeLeft
    }

    pad(value) {
        return padStart(value, 2, '0')
    }

    render() {
        // eslint-disable-next-line no-unused-vars
        const {currentTime, endTime, icon, iconClass, oneHour, onTick, onHide, danger, warning, lastHourOnly, className, ...remain} = this.props

        const iconClassFromProp = iconClass || ''

        return (
            <SecondaryFont>
                <div className={this.buildClasses()} {...remain}>
                    {icon !== 'none' &&
                        <Indicator type={icon}
                            className={`${styles.indicator} ${iconClassFromProp}`}
                            styleType={this.state.status}
                        />
                    }
                    <span className={styles.timeRemaining}>
                        {this.formatTime(this.state.timeLeft , oneHour)}
                    </span>
                </div>
            </SecondaryFont>
        )
    }
}

Timer.propTypes = {
    currentTime: PropTypes.string.isRequired,
    endTime: PropTypes.string.isRequired,
    icon: PropTypes.string,
    iconClass: PropTypes.string,
    oneHour: PropTypes.bool,
    lastHourOnly: PropTypes.bool,
    onTick: PropTypes.func,
    onHide: PropTypes.func,
    danger: PropTypes.shape({
        time: PropTypes.number,
        callback: PropTypes.func,
    }),
    warning: PropTypes.shape({
        time: PropTypes.number,
        callback: PropTypes.func,
    }),
    className: PropTypes.string,
}

Timer.defaultProps = {
    icon: 'timer',
}