import React from 'react'
import {shallow} from 'enzyme'
import {Popover} from '@abc/protonpack'
import PopoverSelect from './'
import PopoverSelectOption from './popoverSelectOption'
import noop from 'lodash/noop'
import range from 'lodash/range'

const testOptionsCount = 6
const testOptions = range(testOptionsCount)
    .map((index) => {
        return {
            label: `Option ${index}`,
            value: `option_${index}`,
            disabled: !!(index % 2),
        }
    })

const defaultState = {
    popoverOpen: false,
}

const optionItem = option => (<div className="fake-option-item">{option.group} - {option.label}</div>)

describe('PopoverSelect', () => {
    describe('Test Elements/DOM', () => {
        let wrapper

        beforeEach(() => {
            wrapper = shallow(
                <PopoverSelect
                    className="fake-popover-select-class-name"
                    options={testOptions}
                    onChange={noop}
                    optionItem={optionItem}
                    placeholder="Fake Placeholder Message"
                    value="option_1"
                    screenReaderMessage="Fake Screen Reader Message"
                    width="280px"
                />
            )
        })

        afterEach(() => {
            wrapper.unmount()
        })

        it('should have a container with a class named "fake-popover-select-class-name"', () => {
            const container = wrapper.find('.fake-popover-select-class-name')
            expect(container.hasClass('fake-popover-select-class-name')).toBe(true)
        })

        it('should contain a single Popover element', () => {
            const popover = wrapper.find(Popover)
            expect(popover.length).toBe(1)
        })

        it('should contain a single select element', () => {
            const selectElement = wrapper.find('select')
            expect(selectElement.length).toBe(1)
        })

        it('should contain a screen reader message', () => {
            const screenReaderMessage = wrapper.find('.screen-reader-only')
            expect(screenReaderMessage.length).toBe(1)
        })

        it('should contain a placeholder on the select node', () => {
            const selectElement = wrapper.find('select')
            expect(selectElement.prop('placeholder')).toBe('Fake Placeholder Message')
        })
    })

    describe('Test Props/State', () => {
        let changeOption
        let wrapper
        let container

        describe('Desktop', () => {
            beforeEach(() => {
                window.matchMedia = jest.fn((query) => {
                    return {
                        matches: query !== '(hover: none)',
                    }
                })
                changeOption = jest.fn()
                wrapper = shallow(
                    <PopoverSelect
                        className="fake-popover-select-class-name"
                        options={testOptions}
                        onChange={changeOption}
                    />
                )
                container = wrapper.find('.container')
                wrapper.setState(defaultState)
                wrapper.instance().closePopover = jest.fn()
            })

            it('should open the Popover on click', () => {
                expect(wrapper.state('popoverOpen')).toEqual(false)
                container.simulate('click')
                expect(wrapper.state('popoverOpen')).toEqual(true)
            })

            it('should not change select on click', () => {
                expect(wrapper.state('popoverOpen')).toEqual(false)
                const option = wrapper.find('select option').at(0)
                option.simulate('click')
                expect(wrapper.find('[selected=true]').node).toBe(undefined)
            })

            it('should not open the Popover when disabled', () => {
                wrapper.setProps({disabled: true})
                expect(wrapper.state('popoverOpen')).toEqual(false)
                container.simulate('click')
                expect(wrapper.state('popoverOpen')).toEqual(false)
            })
        })

        describe('Mobile', () => {
            beforeEach(() => {
                window.matchMedia = jest.fn((query) => {
                    return {
                        matches: query === '(hover: none)',
                    }
                })
                changeOption = jest.fn()
                wrapper = shallow(
                    <PopoverSelect
                        className="fake-popover-select-class-name"
                        options={testOptions}
                        onChange={changeOption}
                    />
                )
                container = wrapper.find('.container')
                wrapper.setState(defaultState)
                wrapper.instance().closePopover = jest.fn()
            })

            it('should not open the Popover on click', () => {
                expect(wrapper.state('popoverOpen')).toEqual(false)
                container.simulate('click')
                expect(wrapper.state('popoverOpen')).toEqual(false)
            })

            it('should open the select on click', () => {
                expect(wrapper.state('popoverOpen')).toEqual(false)
                container.simulate('click')
                expect(wrapper.state('popoverOpen')).toEqual(false)
            })

            it('should not open the select when disabled', () => {
                wrapper.setProps({disabled: true})
                expect(wrapper.state('popoverOpen')).toEqual(false)
                container.simulate('click')
                expect(wrapper.state('popoverOpen')).toEqual(false)
            })
        })
    })

    describe('Test Events/Callbacks', () => {
        let changeOption
        let wrapper

        beforeEach(() => {
            changeOption = jest.fn()
            wrapper = shallow(
                <PopoverSelect
                    className="fake-popover-select-class-name"
                    options={testOptions}
                    onChange={changeOption}
                    screenReaderMessage="fake-screen-reader-message"
                    value="option_0"
                />
            )
            wrapper.instance().setSelectReference(wrapper.find('select'))
            wrapper.setState(defaultState)
            wrapper.instance().closePopover = jest.fn()
        })

        it('should trigger "onChange" method on select change', () => {
            const selectElement = wrapper.find('select')
            selectElement.simulate('change', {target: {value: testOptions[0].value}})
            expect(changeOption).toHaveBeenCalled()
        })

        it('should trigger "onChange" method on enabled popover item clicked', () => {
            const popoverSelectOption = wrapper.find(PopoverSelectOption).first()
            popoverSelectOption.simulate('click')
            expect(changeOption).toHaveBeenCalled()
        })

        it('should not trigger "onChange" method on disabled select change', () => {
            wrapper.setProps({disabled: true})
            const selectElement = wrapper.find('select')
            selectElement.simulate('change', {target: {value: testOptions[0].value}})
            expect(changeOption).not.toHaveBeenCalled()
        })

        it('should set the selectedIndex to -1 when value is changed to empty string and select is focused', () => {
            wrapper.instance().selectNode.value = ''
            wrapper.instance().selectNode.simulate('focus', {target: wrapper.instance().selectNode})
            expect(wrapper.instance().selectNode.selectedIndex).toEqual(-1)
        })

        it('should set the selectedIndex to -1 when value is changed to a value not in the options', () => {
            wrapper.setProps({value: 'fake-non-existant-option'})
            expect(wrapper.instance().selectNode.selectedIndex).toEqual(-1)
        })

        it('should update the selectedIndex when value is changed to null', () => {
            wrapper.setProps({value: null})
            expect(wrapper.instance().selectNode.selectedIndex).toEqual(-1)
        })

        it('should update the selectedIndex when value is changed to an empty string', () => {
            wrapper.setProps({value: ''})
            expect(wrapper.instance().selectNode.selectedIndex).toEqual(-1)
        })
    })
})