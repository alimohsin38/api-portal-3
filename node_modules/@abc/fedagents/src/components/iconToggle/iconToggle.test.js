import React from 'react'
import IconToggle from './'
import Icon from '@abc/quarkicons'
import {mount} from 'enzyme'
import Promise from 'promise'
import noop from 'lodash/noop'

jest.useFakeTimers()

describe('IconToggle', () => {
    describe('render a basic icon toggle', () => {
        const toggleChange = jest.fn()
        const wrapper = mount(
            <IconToggle
                checked={false}
                checkedIcon="x"
                className="fake-toggle-button-class"
                onChange={toggleChange}
                uncheckedIcon="plus"
            />
        )

        const iconElement = wrapper.find(Icon)

        it('should render a ToggleButton with classes', () => {
            expect(wrapper.hasClass('fake-toggle-button-class')).toBe(true)
        })


        it('should render an icon', () => {
            expect(iconElement.type()).toBe(Icon)
        })
    })

    describe('State and Props', () => {
        let wrapper
        let toggleChange
        let iconElement

        beforeEach(() => {
            toggleChange = jest.fn()
            wrapper = mount(
                <IconToggle
                    checked={false}
                    checkedIcon="x"
                    onChange={toggleChange}
                    uncheckedIcon="plus"
                />
            )
            iconElement = wrapper.find(Icon)
        })

        it('should end the waiting if the checked prop changes', () => {
            wrapper.setState({waiting:true})
            wrapper.setProps({checked:!wrapper.prop('checked')})
            expect(wrapper.state('waiting')).toEqual(false)
        })

        it('should render the uncheckedIcon by default', () => {
            wrapper.setProps({checked:false})
            expect(iconElement.prop('type')).toEqual(wrapper.prop('uncheckedIcon'))
        })

        it('should render the checkedIcon when checked', () => {
            wrapper.setProps({checked:true})
            expect(iconElement.prop('type')).toEqual(wrapper.prop('checkedIcon'))
        })
    })

    describe('Events and Callbacks', () => {
        const toggleCancel = jest.fn()

        let toggleChange
        let wrapper

        beforeEach(() => {
            toggleChange = jest.fn()
            wrapper = mount(
                <IconToggle
                    checked={false}
                    checkedIcon="x"
                    onChange={toggleChange}
                    uncheckedIcon="plus"
                />
            )
        })

        it('should trigger "onChange" method on input change', () => {
            wrapper.simulate('click')
            expect(toggleChange).toHaveBeenCalled()
        })

        it('should begin waiting after the set delay', () => {
            wrapper.simulate('click')
            jest.runOnlyPendingTimers()
            expect(wrapper.state('waiting')).toEqual(true)
        })

        it('should end the waiting if the checked prop changes', () => {
            wrapper.setState({waiting:true})
            wrapper.setProps({checked:!wrapper.prop('checked')})
            expect(wrapper.state('waiting')).toEqual(false)
        })

        it('should trigger end the waiting if a returned Promise resolves', (done) => {
            const resolvedPromise = new Promise.resolve(false)
            wrapper.setProps({checked:false})
            wrapper.setState({waiting:true})
            toggleChange.mockReturnValue(resolvedPromise)
            wrapper.simulate('click')
            resolvedPromise.then(() => {
                expect(wrapper.state('waiting')).toEqual(false)
                done()
            })
        })

        it('should trigger end the waiting if a returned Promise is rejected', (done) => {
            const rejectedPromise = new Promise.reject('Cancelled')
            wrapper.setProps({checked:false})
            wrapper.setState({waiting:true})
            toggleChange.mockReturnValue(rejectedPromise)
            wrapper.simulate('click')
            rejectedPromise.then(noop, () => {
                expect(wrapper.state('waiting')).toEqual(false)
                done()
            })
        })

        it('should trigger end the waiting if a returned Promise throws an error', (done) => {
            const errorPromise = new Promise.resolve()
            wrapper.setState({waiting:true})
            toggleChange.mockReturnValue(errorPromise)
            errorPromise.then(() => {
                expect(wrapper.state('waiting')).toEqual(true)
                throw new Error('fake-error')
            }).catch(() => {
                expect(wrapper.state('waiting')).toEqual(false)
                done()
            })
            wrapper.simulate('click')
        })

        it('should trigger end the waiting if a returned Promise is not a Promise', () => {
            wrapper.setState({waiting:true})
            toggleChange.mockReturnValue({})
            wrapper.simulate('click')
            expect(wrapper.state('waiting')).toEqual(false)
        })

        it('should trigger "onCancel" method on click and timeout exists', () => {
            wrapper.setProps({onCancel:toggleCancel})
            wrapper.instance().timeout = 1
            wrapper.simulate('click')
            expect(toggleCancel).toHaveBeenCalled()
        })
    })
})