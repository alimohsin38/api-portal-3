import React, {Component} from 'react'
import PropTypes from 'prop-types'
import {Fade, Modal, ModalHeader, ModalBody, ModalFooter} from 'reactstrap'
import classnames from 'classnames'
import uniqueId from 'lodash/uniqueId'
import Alert from '../alert'
import BaseText from '../typography/baseText'
import Button from '../buttons/button'
import BannerModal from '../banner/modal'
import {getScrollbarWidth} from  'utils/dom'
import {iconMap} from '../indicator'
import Icon from '@abc/quarkicons'
import styles from './modal.scss'
import grid from 'styles/config/_grid.scss'

export const animationState = {
    ENTER: 'open',
    ENTERING: 'opening',
    ENTERED: 'opened',
    EXIT: 'close',
    EXITING: 'closing',
    EXITED: 'closed',
}

export const transitionTypes = {
    FADE: 'fade',
    FLIP: 'flip',
    SLIDE: 'slide',
}

export const transitionDirections = {
    LEFT: 'left',
    RIGHT: 'right',
}

export default class ModalTemplater extends Component {
    constructor(props) {
        super(props)

        this.state = {
            defaultTransitionType: transitionTypes.FADE,
        }

        if (!document.documentElement.style.getPropertyValue('--scrollbarWidth')) {
            document.documentElement.style.setProperty('--scrollbarWidth', `${getScrollbarWidth()}px`)
        }

        this.renderBody = this.renderBody.bind(this)
        this.setModalRef = this.setModalRef.bind(this)
        this.setScrollingContainerRef = this.setScrollingContainerRef.bind(this)
        this.setFocusToAutofocusElement = this.setFocusToAutofocusElement.bind(this)
        this.handleAutoFocus = this.handleAutoFocus.bind(this)
        this.handleMobileMediaQueryTrigger = this.handleMobileMediaQueryTrigger.bind(this)
        this.handleModalBodyScroll = this.handleModalBodyScroll.bind(this)
        this.handleOnEnter = this.handleOnEnter.bind(this)
        this.handleOnEntering = this.handleOnEntering.bind(this)
        this.handleOnEntered = this.handleOnEntered.bind(this)
        this.handleOnExit = this.handleOnExit.bind(this)
        this.handleOnExiting = this.handleOnExiting.bind(this)
        this.handleOnExited = this.handleOnExited.bind(this)
    }

    componentDidMount() {
        this.updateModalClassNames()
        this.mediaQuery = window.matchMedia(`(min-width: ${grid.gridBreakPointMD})`)
        this.setState({
            defaultTransitionType: this.mediaQuery.matches ? transitionTypes.FADE : transitionTypes.SLIDE,
        })
        this.mediaQuery && this.mediaQuery.addListener(this.handleMobileMediaQueryTrigger)
    }

    componentWillUnmount() {
        this.mediaQuery && this.mediaQuery.removeListener(this.handleMobileMediaQueryTrigger)
        delete this.mediaQuery
        const dialog = this.dialog
        dialog && dialog.removeEventListener('transitionend', this.handleAutoFocus, false)
    }

    get dialog() {
        return this.modal
            && this.modal._element
            && this.modal._element.querySelectorAll('.modal-dialog')[0]
    }

    handleAutoFocus(event) {
        const dialog = this.dialog
        this.mediaQuery.matches
            && dialog && event
            && event.target === dialog
            && setTimeout(this.setFocusToAutofocusElement, 0)
    }

    handleOnEnter() {
        const dialog = this.dialog
        dialog && dialog.addEventListener('transitionend', this.handleAutoFocus, false)
        this.updateModalClassNames(animationState.ENTER)
        const callbacks = this.props.modalTransition || this.props || {}
        callbacks.onEnter && callbacks.onEnter.apply(null, arguments)
    }

    handleOnEntering() {
        this.updateModalClassNames(animationState.ENTERING)
        const callbacks = this.props.modalTransition || this.props || {}
        callbacks.onEntering && callbacks.onEntering.apply(null, arguments)
    }

    handleOnEntered() {
        this.updateModalClassNames(animationState.ENTERED)
        const callbacks = this.props.modalTransition || this.props || {}
        callbacks.onEntered && callbacks.onEntered.apply(null, arguments)
    }

    handleOnExit() {
        this.updateModalClassNames(animationState.EXIT)
        const callbacks = this.props.modalTransition || this.props || {}
        callbacks.onExit && callbacks.onExit.apply(null, arguments)
    }

    handleOnExiting() {
        this.updateModalClassNames(animationState.EXITING)
        const callbacks = this.props.modalTransition || this.props || {}
        callbacks.onExiting && callbacks.onExiting.apply(null, arguments)
    }

    handleOnExited() {
        this.updateModalClassNames(animationState.EXITED)
        const callbacks = this.props.modalTransition || this.props || {}
        callbacks.onExited && callbacks.onExited.apply(null, arguments)
    }

    updateModalClassNames(showHide) {
        if (this.modal && this.modal._element) {
            const element = this.modal._element
            const emptyArray = []
            emptyArray.map.call(element.classList, (className) => {
                if (/modal-transition-type-.*/.test(className)) {
                    element.classList.remove(className)
                }
                if (/modal-transition-direction-.*/.test(className)) {
                    element.classList.remove(className)
                }
            })
            Object.keys(animationState).forEach(key => element.classList.remove(animationState[key]))
            showHide && element.classList.add(showHide)
            element.classList.add('modal-wrapper')
            element.classList.add(`modal-transition-type-${this.props.transitionType}`)
            element.classList.add(`modal-transition-direction-${this.props.transitionDirection}`)
        }
    }

    handleMobileMediaQueryTrigger(mediaQuery) {
        this.setState({
            defaultTransitionType: mediaQuery.matches ? transitionTypes.FADE : transitionTypes.SLIDE,
        })
    }

    setFocusToAutofocusElement() {
        const dialog = this.dialog
        const isOpen = dialog && this.modal._element.classList.contains(animationState.ENTERED)
        if (isOpen) {
            if (typeof this.props.autoFocus === 'string' || (this.props.scrollable && this.scrollingContainer)) {
                let focusTarget = this.scrollingContainer

                if (typeof this.props.autoFocus === 'string') {
                    focusTarget = dialog && dialog.querySelectorAll(this.props.autoFocus)[0]
                }

                document.activeElement.blur()
                focusTarget && typeof focusTarget.focus === 'function' && focusTarget.focus()
            }
        }
    }

    setScrollingContainerRef(scrollingContainer) {
        this.scrollingContainer = scrollingContainer
    }

    handleModalBodyScroll(event) {
        this.props.onScroll && this.props.onScroll(event)
    }

    setModalRef(modal) {
        this.modal = modal
    }

    renderAlert(error) {
        return (
            <Alert isOpen {...error}>{error.message}</Alert>
        )
    }

    renderFooterButton(button) {
        const ButtonComponent = button.component || Button
        return (
            <ButtonComponent key={uniqueId()} {...button.props}>{button.text}</ButtonComponent>
        )
    }

    renderBanner(banner) {
        return (
            <BannerModal title={banner.title} indicator={banner.indicator}>
                {banner.children}
            </BannerModal>
        )
    }

    renderBody(children) {
        const {bodyClassName} = this.props

        return (
            <div
                className={classnames(bodyClassName, 'modal-body__scrollable-content')}
                ref={this.setScrollingContainerRef}
                onScroll={this.handleModalBodyScroll}
                tabIndex="0"
            >
                {children}
            </div>
        )
    }

    render() {
        const {
            autoFocus, // eslint-disable-line no-unused-vars
            banner,
            bodyClassName, // eslint-disable-line no-unused-vars
            buttons = [],
            children = [],
            className,
            error,
            isOpen,
            scrollable, // eslint-disable-line no-unused-vars
            overlayHeader,
            staticBackdrop,
            toggle,
            transitionDirection, // eslint-disable-line no-unused-vars
            transitionType, // eslint-disable-line no-unused-vars
            type, // eslint-disable-line no-unused-vars
            ...remain
        } = this.props

        const modalBodyContent = []

        let modalBody
        let modalBanner
        let modalHeader
        let modalFooter

        React.Children.forEach(children, (child) => {
            if (child) {
                if (child.type === ModalHeader) {
                    modalHeader = React.cloneElement(child, {
                        className: classnames(
                            'modal-header',
                            {'modal-header--overlay': overlayHeader},
                            child.className,
                        ),
                    })
                } else if (child.type === BannerModal) {
                    modalBanner = child
                } else if (child.type === ModalFooter) {
                    modalFooter = React.cloneElement(child, {
                        className: classnames(
                            'modal-footer',
                            child.className,
                        ),
                        children: [
                            ...buttons.map(this.renderFooterButton),
                            ...(React.Children.map(child.props.children || [], child => child)),
                        ],
                    })
                } else if (child.type === ModalBody) {
                    modalBody = React.cloneElement(child, {
                        className: classnames(
                            'modal-body',
                            child.className,
                            scrollable ? 'modal-body--scrollable' : undefined,
                        ),
                        children: [
                            error && this.renderAlert(error),
                            this.renderBody(child.props.children),
                        ],
                    })
                } else {
                    modalBodyContent.push(child)
                }
            }
        })

        if (staticBackdrop) {
            remain.backdrop = 'static'
        }

        const timeout = parseInt(styles.modalTransitionDuration, 10)

        const backdropTransition = {
            timeout: {
                enter: timeout,
                exit: timeout,
            },
            ...this.props.backdropTransition,
        }

        const modalTransition = {
            timeout: {
                enter: timeout,
                exit: timeout,
            },
            ...this.props.modalTransition,
            onEnter: this.handleOnEnter,
            onEntering: this.handleOnEntering,
            onEntered: this.handleOnEntered,
            onExit: this.handleOnExit,
            onExiting: this.handleOnExiting,
            onExited: this.handleOnExited,
        }

        return (
            <Modal
                ref={this.setModalRef}
                isOpen={isOpen}
                toggle={toggle}
                {...remain}
                className={className}
                backdropTransition={backdropTransition}
                modalTransition={modalTransition}
                fade={true}
                backdrop={false}
                autoFocus={true}
            >

                {modalHeader ||
                    <ModalHeader
                        className={classnames(
                            'modal-header',
                            {'modal-header--overlay': overlayHeader},
                        )}
                    >
                        <BaseText size="lg">
                            <Icon type="x-heavy" onClick={toggle} aria-label="Close" />
                        </BaseText>
                    </ModalHeader>
                }
                {modalBanner || (banner && this.renderBanner(banner))}
                {modalBody ||
                    <ModalBody
                        className={classnames(
                            'modal-body',
                            scrollable ? 'modal-body--scrollable' : undefined,
                        )}
                    >
                        {error && this.renderAlert(error)}
                        {this.renderBody(modalBodyContent)}
                    </ModalBody>
                }
                {modalFooter || (
                    <ModalFooter className="modal-footer">
                        {
                            buttons.map(this.renderFooterButton)
                        }
                    </ModalFooter>
                )}
            </Modal>
        )
    }
}

const FadePropTypes = PropTypes.shape(Fade.propTypes)

ModalTemplater.propTypes = {
    autoFocus: PropTypes.oneOfType([
        PropTypes.bool,
        PropTypes.string,
    ]),
    toggle: PropTypes.func.isRequired,
    children: PropTypes.node,
    className: PropTypes.string,
    type: PropTypes.oneOf(['basic']),
    staticBackdrop: PropTypes.bool,
    isOpen: PropTypes.bool,
    buttons: PropTypes.arrayOf(PropTypes.shape({
        component: PropTypes.func,
        text: PropTypes.string.isRequired,
        props: PropTypes.object,
    })),
    banner: PropTypes.shape({
        title: PropTypes.string.isRequired,
        indicator: PropTypes.oneOf(Object.keys(iconMap)),
        children: PropTypes.node,
    }),
    error: PropTypes.shape({
        message: PropTypes.string.isRequired,
        type: PropTypes.string,
    }),
    scrollable: PropTypes.bool,
    onScroll: PropTypes.func,
    overlayHeader: PropTypes.bool,
    bodyClassName: PropTypes.string,
    transitionDirection: PropTypes.oneOf(
        Object.keys(transitionDirections)
            .map(key => transitionDirections[key])
    ),
    transitionType: PropTypes.oneOf(
        Object.keys(transitionTypes)
            .map(key => transitionTypes[key])
    ),
    backdropTransition: FadePropTypes,
    modalTransition: FadePropTypes,
}

ModalTemplater.defaultProps = {
    autoFocus: true,
    type: 'basic',
    transitionDirection: transitionDirections.LEFT,
    transitionType: transitionTypes.FLIP,
}