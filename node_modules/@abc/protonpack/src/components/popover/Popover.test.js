import React from 'react'
import {mount} from 'enzyme'
import Popover from './'

describe('Popover', () => {
    let element
    let container

    beforeEach(() => {
        element = document.createElement('div')
        container = document.createElement('div')
        element.innerHTML = '<p id="outerTarget">This is the popover <span id="innerTarget">target</span>.</p>'
        container.setAttribute('id', 'container')
        element.appendChild(container)
        document.body.appendChild(element)

        jest.useFakeTimers()
    })

    afterEach(() => {
        jest.clearAllTimers()
        document.body.removeChild(element)
        element = null
    })

    const run  = (props = {}) => {
        const wrapper = mount(
            <Popover
                isOpen={props.isOpen === undefined ? true : props.isOpen}
                target="innerTarget"
                {...props}
            >
                xyx
            </Popover>
        )

        const popover = document.getElementsByClassName('popover')[0]

        return {wrapper, popover}
    }

    describe('basic render', () => {
        it('should have default classes', () => {
            const {wrapper, popover} = run()
            expect(popover.classList.contains('popover')).toBe(true)
            wrapper.unmount()
        })

        it('should have a .popover-inner and .arrow child', () => {
            const {wrapper, popover} = run()
            expect(popover.innerHTML).toEqual('<div class="popover-inner">xyx</div><span class="arrow"></span>')
            wrapper.unmount()
        })

        it('should have a state attribute placement equal to the placement prop', () => {
            const {wrapper} = run({
                placement: 'fake-placement',
            })
            expect(wrapper.state('placement')).toEqual('fake-placement')
            wrapper.unmount()
        })
    })

    describe('props', () => {
        it('should handle \'isOpen\' change', () => {
            const {wrapper} = run({isOpen: false})
            let popover = document.getElementsByClassName('popover')[0]
            expect(popover).toBeUndefined()
            wrapper.setProps({isOpen: true})
            popover = document.getElementsByClassName('popover')[0]
            expect(popover).toBeDefined()
            wrapper.unmount()
        })

        it('should change placement state when \'placement\' prop changes', (done) => {
            const {wrapper} = run()
            expect(wrapper.state('placement')).toBeUndefined()
            wrapper.setProps({placement: 'auto'}, () => {
                expect(wrapper.update().state('placement')).toEqual('auto')
                wrapper.unmount()
                done()
            })
        })

        it('should not change placement state when \'placement\' prop changes and you are on mobile device', (done) => {
            window.matchMedia().matches = false
            const {wrapper} = run()
            expect(wrapper.state('placement')).toEqual('bottom')
            wrapper.setProps({placement: 'auto'}, () => {
                expect(wrapper.update().state('placement')).toEqual('bottom')
                wrapper.unmount()
                window.matchMedia().matches = true
                done()
            })
        })

        it('should handle \'width\' change', () => {
            const {wrapper} = run()
            wrapper.setProps({width: 'fake-width-changed'})
            wrapper.update()
            expect(document.documentElement.style).toHaveProperty('PopoverWidth', 'fake-width-changed')
            wrapper.unmount()
        })

        it('should handle passed \'width\'', () => {
            const {wrapper} = run({
                width: 'fake-width-passed',
            })
            expect(document.documentElement.style).toHaveProperty('PopoverWidth', 'fake-width-passed')
            wrapper.unmount()
        })
    })

    describe('placement props', () => {
        const placementOptions = [
            'top',
            'top-start',
            'top-end',
            'right',
            'right-start',
            'right-end',
            'bottom',
            'bottom-start',
            'bottom-end',
            'left',
            'left-start',
            'left-end',
        ]

        placementOptions.forEach((placement) => {
            it(`should have placement 'bs-popover-${placement}' class`, () => {
                const {wrapper} = run({
                    placement,
                })
                expect(wrapper.state('placement')).toEqual(placement)
                wrapper.unmount()
            })
        })
    })

    describe('mobile browser', () => {
        it('should have a placement of \'bottom\' when on mobile', () => {
            window.matchMedia().matches = false
            const {wrapper} = run()
            expect(wrapper.state('placement')).toEqual('bottom')
            window.matchMedia().matches = true
            wrapper.unmount()
        })
    })

    describe('mediaQuery callbacks', () => {
        it('should switch placement to \'bottom\' when desktop -> mobile resize', () => {
            const {wrapper} = run({
                placement: 'fake-placement',
            })
            expect(wrapper.state('placement')).toEqual('fake-placement')
            window.matchMedia().matches = false
            window.matchMedia().onchange()
            expect(wrapper.state('placement')).toEqual('bottom')
            window.matchMedia().matches = true
            wrapper.unmount()
        })

        it('should switch placement to original placement when mobile -> desktop resize', () => {
            window.matchMedia().matches = false
            const {wrapper} = run({
                placement: 'fake-placement',
            })
            expect(wrapper.state('placement')).toEqual('bottom')
            window.matchMedia().matches = true
            window.matchMedia().onchange()
            expect(wrapper.state('placement')).toEqual('fake-placement')
            wrapper.unmount()
        })
    })
})